# クロージャー関数

関数の外部にある変数にアクセスできる関数

★見分け方

クロージャーかどうかを見分けるためには、その関数が外部のスコープにある変数に依存しているかどうかを見る必要があります。クロージャーは、関数の外に定義されている変数をキャプチャして、それを使う関数のこと。

例

```
package main

import "fmt"

func counter() func() {
    ctr := 0
    fmt.Println("カウンタは初期化しました")
    return func() {
        ctr++
        fmt.Println(ctr)
    }
}

func main() {
    counterfunc := counter()
    counterfunc()
    counterfunc()
    counterfunc()
}
```

出力結果

```
カウンタは初期化しました
1
2
3
```

この関数で疑問だったのが、「カウンタは初期化しました」というメッセージが一度しか出力されていないこと。

この疑問が出たのは、```counterfunc := counter()```の解釈に誤りがあった。

counterfuncに代入されているのは以下のコード部分。
(実際、```counter()```の戻り値は```func()```となっていることから明らか)

```
return func() {
        ctr++
        fmt.Println(ctr)
    }
```

では、「カウンタは初期化しました」というメッセージはどこで呼び出されているのか。それは、以下の右辺の```counter()```部分

```
counterfunc := counter()
```

だから、一度しか「カウンタは初期化しました」というメッセージが出力されなかった。


# なぜ、counterfuncはctrを参照できるのか（ポインタを使わなくても動く理由）

Goでは、クロージャが外部の変数をキャプチャするとき、変数自体をコピーするのではなく、メモリ上の参照（アドレス）を保持する。

つまり、&ctrのように明示的にポインタを使わなくても、クロージャの内部では暗黙的にctrのアドレスが保持されているため、クロージャの外部にある変数（ここではctr）を更新することができる。
