#　定義

```
var msgs []string
```

配列との違い => []の中に長さを入れるか入れるかどうか

# スライスの要素の追加

```
msgs = append(msgs, "こんにちは")
```

# スライスの内部構造とappend

appendは、「元のスライスを直接更新せずに、新しいスライスを作って返す」」が、スライスの中の要素は別で配列に保管されていて、スライス自体は最低限の情報しか持っていない軽量の構造体


# スライスの値代入と参照

```
msgs[0] = "hello"
fmt.Println(msgs[0])
// -> hello
```

- 初期化と代入を一度に
  ```
  msgs := []string{"Hello", "こんにちは"}
  ```


  # スライスの容量

  スライスは可変長だが、容量をもつ。

  スライスは、その容量を超えるまでは、同じ配列に内部で値を追加しています。そして、容量を超えたら、新しい配列を内部で作り直しているのです。このような処理を内部で行うことで、可変長配列としての機能を提供しています。

  ***容量を超えたら配列を作り直すことになるので、できるだけその処理が行われないように、具体的に入りうる値の数に見当がつく際は容量を設定しておいた方がパフォーマンスがよくなる。***

  - 容量つきで初期化
    
    ```
    strs := make([]string, 0, 2)
    ```

    makeは、スライス等の一部の型を初期化できる関数。

    - 実際に、入っている値の数と容量を確認

      ```
      strs1 := make([]string, 0, 2)
      fmt.Printf("入っている値の数: %v\n", len(strs1))
      // -> 入っている値の数: 0
      // -> 容量: 2
      fmt.Printf("容量: %v\n", cap(strs1))

      strs2 := make([]string, 2)
      fmt.Printf("入っている値の数: %v\n", len(strs2))
      // -> 入っている値の数: 2
      fmt.Printf("容量: %v\n", cap(strs2))
      // -> 容量: 2
      ```

      このスライスに値を実際に足すと、容量が増えていることも確認できる。

      ```
      strs2 = append(strs2, "something")
      fmt.Printf("入っている値の数: %v\n", len(strs2))
      // -> 入っている値の数: 3
      fmt.Printf("容量: %v\n", cap(strs2))
      // -> 容量: 4
      ```

      

    
